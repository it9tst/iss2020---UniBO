System -msglog tearoom

// MESSAGES SMARTBELL
// Message between smartbell - client
Request  enterRequestClient					: enterRequestClient (TEMP)
Reply    enterReplyFromSmartbell			: enterReplyFromSmartbell (ID, TABLE)
Reply    enterReplyFromSmartbellNeg			: enterReplyFromSmartbellNeg (PAYLOAD)
Reply 	 enterReplyFromSmartbellWithTime 	: enterReplyFromSmartbellWithTime (ID, MAXSTAYTIME)
Dispatch goToWaitRing 						: goToWaitRing (PAYLOAD)

// Message between smartbell - waiter
Request smartbellEnterRequest	: smartbellEnterRequest (ID)		
Reply   clientAccept			: clientAccept (TABLE)
Reply	clientAcceptWithTime 	: clientAcceptWithTime (MAXSTAYTIME)

// MESSAGES BARMAN
// Message between barman - waiter
Dispatch sendOrder 				: sendOrder (ID, ORD)
Dispatch barmanCompleteOrder 	: barmanCompleteOrder (ID, ORD)

// MESSAGES WAITER
// Message between waiter - client
Dispatch informMaxWaitingTime	: informMaxWaitingTime (PAYLOAD)
Dispatch convoyToTable			: convoyToTable (TABLE)
Dispatch clientReadyToOrder 	: clientReadyToOrder (ID, ORD)
Dispatch clientPayment 			: clientPayment (ID)

// Message between waiterengine - waitermind
Dispatch engineReady	: engineReady (PAYLOAD)
Request	 moveTo			: moveTo (X, Y)
Reply	 done			: done (X, Y)
Request	 clean			: clean (STATE)
Reply	 cleanDone		: cleanDone (PAYLOAD)

// Message between waiterengine - basicrobot
Request  step 		: step (STEPTIME)
Reply    stepdone 	: stepdone (V)
Reply    stepfail   : stepfail (DURATION, CAUSE)
Dispatch cmd 		: cmd (CMD)

Dispatch goToClearing 	: goToClearing (PAYLOAD)
Dispatch goToSanitizing : goToSanitizing (PAYLOAD)
Dispatch goToCleaning 	: goToCleaning (PAYLOAD)

// MESSAGES MAXSTAYTIME
Dispatch startTimer				: startTimer (TABLE)
Dispatch stopTimer				: stopTimer (TABLE)
Dispatch resumeTimer			: resumeTimer (TABLE)
Dispatch maxStayTimerExpired	: maxStayTimerExpired (TABLE)

Request maxStayTimerLeftRequest			: maxStayTimerLeftRequest (TABLE)
Reply maxStayTimerLeftReply				: maxStayTimerLeftReply (TIMERLEFT)
Request maxStayTimerLeftRequestToTable	: maxStayTimerLeftRequestToTable (PAYLOAD)
Reply maxStayTimerLeftReplyFromTable	: maxStayTimerLeftReplyFromTable (TIMERLEFT)
Request maxStayTimerLeftCompareRequest	: maxStayTimerLeftCompareRequest (TABLE)
Reply maxStayTimerLeftCompareReply		: maxStayTimerLeftCompareReply (TIMERLEFT)

Dispatch end : end (PAYLOAD)


Context ctxtearoom ip [host="localhost" port=50810]
Context ctxbasicrobot ip [host="192.168.10.100" port=50800]

ExternalQActor basicrobot context ctxbasicrobot


QActor waitermind context ctxtearoom {

	[#
		// Init variable
		var Table1_states = arrayOf(1, 1, 1, 1, -1) // 0. Table_isFree, 1. Table_isCleared, 2. Table_isCleaned, 3. Table_isSanitized, 4. ID_client
		var Table2_states = arrayOf(1, 1, 1, 1, -1) // 0. Table_isFree, 1. Table_isCleared, 2. Table_isCleaned, 3. Table_isSanitized, 4. ID_client
		var ID_client = 0
		var Table1_ID = 1
		var Table2_ID = 2
		var ORD_client: String = ""
		var TableSelectedToConvoy = 0
		var TableSelectedToClean = 0
		
		val DelayTakeClient = 2000L
		val DelayTakeOrder = 5000L
		val DelayTakeDrink = 2000L
		val DelayCollectTime = 4000L
		
		// Table state delay
		var MaxWaitingTime = 0L
		var MaxWaitingTime1 = 0L
		var MaxWaitingTime2 = 0L
		var TableDelayCleaning = arrayOf(0, 6000, 6000, 5000)
		
		// Home Position
		val X_home = "0"
		val Y_home = "0"
		
		// Barman Position
		val X_barman = "6"
		val Y_barman = "0"
	
		// Entrance Position
		val X_entrance = "0"
		val Y_entrance = "4"
		
		// Exit Position
		val X_exit = "6"
		val Y_exit = "4"
		
		// Table1 Position
		val X_table1 = "2"
		val Y_table1 = "2"
		
		// Table2 Position
		val X_table2 = "4"
		val Y_table2 = "2"

	#]
	
	State s0 initial {
		// Initial state
		println("WAITERMIND | Start")
	}
	Transition t0	whenMsg engineReady -> rest
	
	State rest {
		// Waiter is at home
		println("WAITERMIND | Rest")
	}
	Goto checkQueue

	State checkQueue{
		// Waiter check queue
		println("WAITERMIND | checkQueue")
	}
	Transition t1	whenTime 100 -> checkTableToClean
					whenRequest smartbellEnterRequest -> accept
					whenMsg clientReadyToOrder -> takeOrder
					whenMsg barmanCompleteOrder -> reachBarman
					whenMsg clientPayment -> collectPayment
					whenMsg maxStayTimerExpired -> collectPayment
					whenMsg end -> endWork
	
	State checkTableToClean{
		// Waiter check table to clean
		println("WAITERMIND | checkTableToClean")
		
		if [# Table1_states.get(0) == 1 && Table1_states.get(1) == 0 #]{
				[#
					TableSelectedToClean = 1
				#]
			} else {
				if [# Table2_states.get(0) == 1 && Table2_states.get(1) == 0 #]{
					[#
						TableSelectedToClean = 2
					#]
				}
			}		
	}
	Goto reachHome if [# TableSelectedToClean == 0 #] else reachTableClean

	State reachHome{
		// Waiter reach home
		println("WAITERMIND | Reach Home")
		
		delay 3000
		request waiterengine -m moveTo : moveTo ($X_home, $Y_home)
		
	}
	Transition t2	whenReply done -> rest
	
	State accept {
		// Waiter accept the client
		println("WAITERMIND | accept")
		
		if [# Table1_states.get(3) == 1 #]{
			// Table1 is free and clean
			onMsg(smartbellEnterRequest : smartbellEnterRequest (ID)){
				println("WAITERMIND | Accept the client with ID: ${payloadArg(0)}")
			}
			replyTo smartbellEnterRequest with clientAccept : clientAccept (1)
			[#
				Table1_states.set(4, payloadArg(0).toInt())
			#]
			forward waitermind -m convoyToTable : convoyToTable (1)
			
		} else {
			if [# Table2_states.get(3) == 1 #]{
				// Table2 is free and clean
				onMsg(smartbellEnterRequest : smartbellEnterRequest (ID)){
					println("WAITERMIND | Accept the client with ID: ${payloadArg(0)}")
				}
			  	replyTo smartbellEnterRequest with clientAccept : clientAccept (2)
			  	[#
					Table2_states.set(4, payloadArg(0).toInt())
				#]
			  	forward waitermind -m convoyToTable : convoyToTable (2)
			  	
			} else {
				if [# Table1_states.get(0) == 0 && Table2_states.get(0) == 0 #]{
					request maxstaytime -m maxStayTimerLeftCompareRequest : maxStayTimerLeftCompareRequest (1)
					
				} else {
					if [# Table1_states.get(0) == 0 #]{
					// Table1 is busy
					request maxstaytime -m maxStayTimerLeftRequest : maxStayTimerLeftRequest (1)
					
					} else {
						if [# Table2_states.get(0) == 0 #]{
							// Table2 is busy
							request maxstaytime -m maxStayTimerLeftRequest : maxStayTimerLeftRequest (2)
							
						} else {
							// Table1 and Table2 are not busy but are dirty
							forward waitermind -m informMaxWaitingTime : informMaxWaitingTime (PAYLOAD)
						}
					}
				}
			}
		}
	}
	Transition t3	whenMsg convoyToTable -> reachDoor
					whenMsg informMaxWaitingTime -> inform
					whenReply maxStayTimerLeftReply -> maxStayTimeLeft
					whenReply maxStayTimerLeftCompareReply -> maxStayTimeLeftTable2
	
	State maxStayTimeLeftTable2{
		onMsg(maxStayTimerLeftCompareReply : maxStayTimerLeftCompareReply (TIMERLEFT)){
			println("WAITERMIND | Maximum waiting time from the busy table is: ${payloadArg(0)} milliseconds")
			[#
				MaxWaitingTime1 = payloadArg(0).toLong()
			#]
		}
		request maxstaytime -m maxStayTimerLeftCompareRequest : maxStayTimerLeftCompareRequest (2)
	}
	Transition t15	whenReply maxStayTimerLeftCompareReply -> maxStayTimeLeftCompare
	
	State maxStayTimeLeftCompare{
		onMsg(maxStayTimerLeftCompareReply : maxStayTimerLeftCompareReply (TIMERLEFT)){
			println("WAITERMIND | Maximum waiting time from the busy table is: ${payloadArg(0)} milliseconds")
			[#
				MaxWaitingTime2 = payloadArg(0).toLong()
			#]
		}
		
		if[# MaxWaitingTime1 < MaxWaitingTime2 #] {
			[#
				MaxWaitingTime += MaxWaitingTime1
				
				for (i in 1..3){
					if (Table1_states.get(i) == 0) {
						MaxWaitingTime += TableDelayCleaning.get(i)
					}
				}
			#]
		} else {
			[#
				MaxWaitingTime += MaxWaitingTime2
				
				for (i in 1..3){
					if (Table2_states.get(i) == 0) {
						MaxWaitingTime += TableDelayCleaning.get(i)
					}
				}
			#] 
		}
		
		println("WAITERMIND | The total maximum waiting time is $MaxWaitingTime milliseconds")
		
		replyTo smartbellEnterRequest with clientAcceptWithTime : clientAcceptWithTime ($MaxWaitingTime)
		
		// TEST01
		updateResource [# "$MaxWaitingTime" #]
		[# readLine() #]
		// TEST01
		
		[#
			MaxWaitingTime = 0L 
		#]
	}
	Goto rest
	
	State maxStayTimeLeft {
		// Get max stay time from the busy table to calculate the maximum waiting time and inform the client
		onMsg(maxStayTimerLeftReply : maxStayTimerLeftReply (TIMERLEFT)){
			println("WAITERMIND | Maximum waiting time from the busy table is: ${payloadArg(0)} milliseconds")
			[#
				MaxWaitingTime = payloadArg(0).toLong()
			#]
		}
	}
	Goto inform
	
	State inform {
		// Waiter inform the client about the maximum waiting time if there is no tableclean
		println("WAITERMIND | Inform the client about the total maximum waiting time")
		
		if [# Table1_states.get(0) == 0 #]{
			[#
				for (i in 1..3){
					if (Table1_states.get(i) == 0) {
						MaxWaitingTime += TableDelayCleaning.get(i)
					}
				}
			#]
		} else {
			if [# Table2_states.get(0) == 0 #]{
				[#
					for (i in 1..3){
						if (Table2_states.get(i) == 0) {
							MaxWaitingTime += TableDelayCleaning.get(i)
						}
					}
				#]
			}
		}
		println("WAITERMIND | The total maximum waiting time is $MaxWaitingTime milliseconds")
		
		replyTo smartbellEnterRequest with clientAcceptWithTime : clientAcceptWithTime ($MaxWaitingTime)
		
		[#
			MaxWaitingTime = 0L 
		#]
	}
	Goto rest
	
	State reachDoor{
		// Waiter reach door
		println("WAITERMIND | Reach Door")
		
		onMsg(convoyToTable : convoyToTable (TABLE)){
			[#
				TableSelectedToConvoy = payloadArg(0).toInt()
			#]
		}
		request waiterengine -m moveTo : moveTo($X_entrance, $Y_entrance)
	}
	Transition t4	whenReply done -> convoyTable
	
	State convoyTable {
		// Waiter convoy the client to table
		delayVar DelayTakeClient
		println("WAITERMIND | Convoy the client to table")
		
		if [# TableSelectedToConvoy == 1 #]{
			[#
				Table1_states.set(0, 0)
				Table1_states.set(1, 0)
				Table1_states.set(2, 0)
				Table1_states.set(3, 0)
			#]

			request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
			forward maxstaytime -m startTimer : startTimer(1)
		} else {
			[#
				Table2_states.set(0, 0)
				Table2_states.set(1, 0)
				Table2_states.set(2, 0)
				Table2_states.set(3, 0)
			#]

			request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
			forward maxstaytime -m startTimer : startTimer(2)
		}
	}
	Transition t5	whenReply done -> reachHome

	State takeOrder{
		// Waiter take the order
		println("WAITERMIND | takeOrder")
		
		onMsg(clientReadyToOrder : clientReadyToOrder (ID, ORD)){
			println("WAITERMIND | go to table for take the order from client with ID: ${payloadArg(0)} and ORD: ${payloadArg(1)}")
			
			if [# Table1_states.get(4) == payloadArg(0).toInt() #]{
				request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
				forward maxstaytime -m stopTimer : stopTimer(1)
			} else {
				request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
				forward maxstaytime -m stopTimer : stopTimer(2)
			}
						
			[#  
				ID_client = payloadArg(0).toInt()
				ORD_client = payloadArg(1).toString()
			#]
		}
	}
	Transition t6	whenReply done -> sendOrderToBarman
	
	State sendOrderToBarman{
		// Waiter send the order to Barman
		delayVar DelayTakeOrder
		println("WAITERMIND | sendOrderToBarman")

		println("WAITERMIND | go to barman for send the order from client with ID: $ID_client and ORD: $ORD_client")

		request waiterengine -m moveTo : moveTo ($X_barman, $Y_barman)

		forward barman -m sendOrder : sendOrder ($ID_client, $ORD_client)
	}
	Transition t7	whenReply done -> reachHome
	
	State reachBarman{
		// Waiter reach Barman
		println("WAITERMIND | Reach Barman")
		
		onMsg(barmanCompleteOrder : barmanCompleteOrder (ID, ORD)){
			println("WAITERMIND | go to barman for the order for client with ID: ${payloadArg(0)} and ORD: ${payloadArg(1)}")
			
			[#  
				ID_client = payloadArg(0).toInt()
				ORD_client = payloadArg(1).toString()
			#]
		}
		
		request waiterengine -m moveTo : moveTo ($X_barman, $Y_barman)
	}
	Transition t8	whenReply done -> serve
	
	State serve{
		// Barman complete the order and send it to Waiter that serve to the Client
		delayVar DelayTakeDrink
		println("WAITERMIND | serve")
		
		if [# Table1_states.get(4) == ID_client #]{
			request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
			forward maxstaytime -m resumeTimer : resumeTimer(1)
		} else {
			request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
			forward maxstaytime -m resumeTimer : resumeTimer(2)
		}
	}
	Transition t9	whenReply done -> reachHome
	
	State collectPayment {
		// Waiter collect the payment
		println("WAITERMIND | collectPayment")
		
		onMsg(clientPayment : clientPayment (ID)){
			println("WAITERMIND | go to client with ID: ${payloadArg(0)} for collect the payment")
			
			if [# Table1_states.get(4) == payloadArg(0).toInt() #]{
				[#
					TableSelectedToClean = 1
				#]
				request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
				forward maxstaytime -m stopTimer : stopTimer(1)
			} else {
				[#
					TableSelectedToClean = 2
				#]
				request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
				forward maxstaytime -m stopTimer : stopTimer(2)
			}
		}
		
		onMsg(maxStayTimerExpired : maxStayTimerExpired (TABLE)){
			println("WAITERMIND | go to client of the table ${payloadArg(0)} for collect the payment, because the time has expired")
			
			if [# payloadArg(0).toInt() == 1 #]{
				[#
					TableSelectedToClean = 1
				#]
				request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
			} else {
				[#
					TableSelectedToClean = 2
				#]
				request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
			}
		}
	}
	Transition t10	whenReply done -> convoyExit
	
	State convoyExit {
		// Waiter convoy the Client to the exitdoor
		delayVar DelayCollectTime
		println("WAITERMIND | Convoy the Client to the exitdoor")

		request waiterengine -m moveTo : moveTo ($X_exit, $Y_exit)
		[#
			when(TableSelectedToClean) {
				1 -> {
					Table1_states.set(0, 1)
				}
				
				2 -> {
					Table2_states.set(0, 1)
				}
			}
			
		#]
	}
	Transition t11	whenReply done -> checkQueue
	
	State reachTableClean{
		// Waiter reach table to clean
		println("WAITERMIND | reachTableClean")
		
		delay 1000

		if [# TableSelectedToClean == 1 #]{
			request waiterengine -m moveTo : moveTo ($X_table1, $Y_table1)
		}
		if [# TableSelectedToClean == 2 #]{
			request waiterengine -m moveTo : moveTo ($X_table2, $Y_table2)
		}
			
	}
	Transition t12 	whenReply done -> whichCleanState
	
	State whichCleanState{
		// Waiter sees what state of cleanliness of the table to do
		println("WAITERMIND | whichCleanState")
		
		if [# TableSelectedToClean == 1 #]{
			if [# Table1_states.get(1) == 0 #] {
				forward waitermind -m goToClearing : goToClearing(PAYLOAD)
			} else {
				if [# Table1_states.get(2) == 0 #] {
					forward waitermind -m goToCleaning : goToCleaning(PAYLOAD)
				} else {
					if [# Table1_states.get(3) == 0 #] {
						forward waitermind -m goToSanitizing : goToSanitizing(PAYLOAD)
					}
				}
			}
		}
		
		if [# TableSelectedToClean == 2 #]{
			if [# Table2_states.get(1) == 0 #] {
				forward waitermind -m goToClearing : goToClearing(PAYLOAD)
			} else {
				if [# Table2_states.get(2) == 0 #] {
					forward waitermind -m goToCleaning : goToCleaning(PAYLOAD)
				} else {
					if [# Table2_states.get(3) == 0 #] {
						forward waitermind -m goToSanitizing : goToSanitizing(PAYLOAD)
					}
				}
			}
		}
	}
	Transition t13	whenMsg goToClearing 	-> tableCleared
					whenMsg goToCleaning 	-> tableCleaned
					whenMsg goToSanitizing 	-> tableSanitized
	
	State tableCleared {
		// Waiter tableCleared
		println("WAITERMIND | tableCleared")
		
		request waiterengine -m clean : clean (1)
		[#
			when(TableSelectedToClean) {
				1 -> {
					Table1_states.set(1, 1)
				}
					
				2 -> {
					Table2_states.set(1, 1)
				}				
			}
		#]
	}
	Transition t14 	whenReply cleanDone -> checkQueue
	
	State tableCleaned {
		// Waiter tableCleaned
		println("WAITERMIND | tableCleaned")
		
		request waiterengine -m clean : clean (2)
		[#
			when(TableSelectedToClean) {
				1 -> {
					Table1_states.set(2, 1)
				}
					
				2 -> {
					Table2_states.set(2, 1)
				}				
			}	
		#]
	}
	Transition t15 	whenReply cleanDone -> checkQueue
	
	State tableSanitized {
		// Waiter tableSanitized
		println("WAITERMIND | tableSanitized")
		
		request waiterengine -m clean : clean (3)
		[#
			when(TableSelectedToClean) {
				1 -> {
					Table1_states.set(3, 1)
				}
					
				2 -> {
					Table2_states.set(3, 1)
				}				
			}
			TableSelectedToClean = 0
		#]
	}
	Transition t16 	whenReply cleanDone -> checkQueue
	
	State endWork {
		// Waiter end work
		println("WAITERMIND | End work")
		terminate 0
	}
}

QActor waiterengine context ctxtearoom{
	[#
		// Robot
		var StepTime = 260L
		val BackTime = 2 * StepTime / 3
		
		// Map
		val mapRoom = "teaRoomExplored"
		var XPoint = "0"
		var YPoint = "0"

		// Table state delay
		val TableClearTime = 6000L
		val TableCleanTime = 6000L
		val TableSanitizedTime = 5000L

		var CmdToMove = ""
	#]
		
	State s0 initial{
		// Initial state
		println("WAITERENGINE | Start")
		
		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.plannerUtil.loadRoomMap(mapRoom)
		run itunibo.planner.plannerUtil.showCurrentRobotState()
		
		forward waitermind -m engineReady : engineReady(PAYLOAD)
	}
	Goto waitCmd
	
	State waitCmd{
		// Wait Cmd
		println("WAITERENGINE | Wait Cmd")
	}
	Transition t0	whenRequest moveTo -> planDestination
				 	whenRequest clean -> cleanTable
				 	whenMsg end -> endWork
	
	State planDestination{
		// Plan Destination
		println("WAITERENGINE | Plan Destination")
		
		onMsg(moveTo : moveTo(X, Y)){
			[# 
				XPoint = payloadArg(0)
			    YPoint = payloadArg(1)			  
			#]
		}
		println("WAITERENGINE | Start moveTo ($XPoint, $YPoint)")
		run itunibo.planner.plannerUtil.planForGoal("$XPoint", "$YPoint")
	}
	Goto readStep
	
	State readStep{
		// Read Step
		println("WAITERENGINE | Read Step")
		
		[# 
			CmdToMove = itunibo.planner.plannerUtil.getNextPlannedMove()
		#]
	}
	Goto execStep if [# CmdToMove == "w" #] else execMove

	State execStep{
		// Exec Step
		println("WAITERENGINE | Exec Step")
		
		request basicrobot -m step : step($StepTime)
	}
	Transition t1	whenReply stepdone -> updateMap
					whenReply stepfail -> errorHandler

	State execMove{
		// Exec Move
		println("WAITERENGINE | Exec Move")
		
		forward basicrobot -m cmd : cmd($CmdToMove)
		delay 200
	}
	Goto updateMap
	
	State updateMap{
		// Update Map
		println("WAITERENGINE | Update Map")
		
		updateResource [# itunibo.planner.plannerUtil.getMapOneLine() #]
		run itunibo.planner.plannerUtil.updateMap("$CmdToMove")	
		
	}
	Goto readStep if [# CmdToMove.length > 0 #] else endDestination
	
	State errorHandler{
		// Error Handler
		println("WAITERENGINE | Error Handler")
		
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[#
				val D = payloadArg(0).toLong()
				val Dt = Math.abs(StepTime - D)
				val BackT = D/2
			#] 
			println("WAITERENGINE | Robotmapper stepFail - D = $D, BackTime = ${BackTime}, BackT = $BackT")
 			if [# D > BackTime #] {    
				forward basicrobot -m cmd : cmd(s)
				delayVar BackT
				forward basicrobot -m cmd : cmd(h)
			}
	 		run itunibo.planner.plannerUtil.showCurrentRobotState()
			updateResource [# "stepFail" #]
			delay 500
		}	    
	}
	Goto readStep if [# CmdToMove.length > 0 #] else endDestination
	
	State cleanTable{
		// Clean Table
		println("WAITERENGINE | Clean Table")
		
		onMsg(clean : clean(STATE)){
			[#
				when(payloadArg(0).toInt()) {
					1 -> {
						println("WAITERENGINE | tableCleared")
						delay(TableClearTime)
					}
					
					2 -> {
						println("WAITERENGINE | tableCleaned")
						delay(TableCleanTime)
					}
					
					3 -> {
						println("WAITERENGINE | tableSanitized")
						delay(TableSanitizedTime)
					}
				}
			#]
		}
		replyTo clean with cleanDone : cleanDone (PAYLOAD)
	}
	Goto waitCmd
	
	State endDestination{
		// End Destination
		println("WAITERENGINE | End Destination")
		
		println("WAITERENGINE | Done moveTo($XPoint,$YPoint)")
		run itunibo.planner.plannerUtil.showCurrentRobotState()
		replyTo moveTo with done : done ($XPoint, $YPoint)
	}
	Goto waitCmd
	
	State endWork {
		// WaiterEngine end work
		println("WAITERENGINE | End work")
		terminate 0
	}
}

QActor smartbell context ctxtearoom {
	[#
		val TempMax = 37.5
		var ClientTemp = 36.0
		var ID_client = 0
	#]
	
	State s0 initial {
		// Smartbell initial state
		println("SMARTBELL | Start")
	}
	Goto waitRing
	
	State waitRing {
		// Smartbell wait ring
		println("SMARTBELL | Wait ring")
	}
	Transition t0 	whenRequest enterRequestClient -> checkTempClient
					whenMsg end -> endWork
						
	State checkTempClient {
		// Smartbell check temp client
		println("SMARTBELL | Check temp client")

		onMsg(enterRequestClient : enterRequestClient (TEMP)){
			println("SMARTBELL | Entry request from CLIENT with ID: $ID_client and TEMP: ${payloadArg(0)}")
			[# ClientTemp = payloadArg(0).toDouble() #]
		}
		
		if [# ClientTemp < TempMax #] {
			println("SMARTBELL | The client can enter - Temp Ok")
			request waitermind -m smartbellEnterRequest : smartbellEnterRequest ($ID_client)
		} else {
			println("SMARTBELL | The client can't enter - Temp Ko")
			replyTo enterRequestClient with enterReplyFromSmartbellNeg : enterReplyFromSmartbellNeg ($ID_client)
			forward smartbell -m goToWaitRing : goToWaitRing (PAYLOAD)
		}
	}
	Transition t1	whenReply clientAccept -> clientEnter
					whenReply clientAcceptWithTime -> clientEnterWithTime
					whenMsg goToWaitRing -> waitRing
	
	State clientEnter{
		// Smartbell reply to client
		println("SMARTBELL | The client can enter")
		
		onMsg(clientAccept : clientAccept (TABLE)){
			replyTo enterRequestClient with enterReplyFromSmartbell : enterReplyFromSmartbell ($ID_client, $payloadArg(0))
		}
		[# ID_client++ #]
	}
	Goto waitRing
	
	State clientEnterWithTime{
		// Smartbell reply to client the max wait time
		println("SMARTBELL | The client must wait time")
		
		onMsg(clientAcceptWithTime : clientAcceptWithTime (MAXWAITINGTIME)){
			replyTo enterRequestClient with enterReplyFromSmartbellWithTime : enterReplyFromSmartbellWithTime ($ID_client, $payloadArg(0))
		}
		[# ID_client++ #]
	}
	Goto waitRing

	State endWork {
		// Smartbell end work
		println("SMARTBELL | End work")
		terminate 0
	}
}

QActor barman context ctxtearoom {
	
	[#
		val TimePrepareOrder = 20000L
	#]
	
	State s0 initial {
		// Barman initial state
		println("BARMAN | Start")
	}
	Goto waitOrder
	
	State waitOrder {
		// Barman wait order
		println("BARMAN | Wait order")
	}
	Transition t0	whenMsg sendOrder -> prepareOrder
					whenMsg end -> endWork

	State prepareOrder {
		// Barman prepare order
		println("BARMAN | prepareOrder")
		
		onMsg(sendOrder : sendOrder (ID, ORD)){
			println("BARMAN | Prepare order for client with ID: ${payloadArg(0)} and ORD: ${payloadArg(1)}")
			delayVar TimePrepareOrder
			println("BARMAN | Order ready for client with ID: ${payloadArg(0)} and ORD: ${payloadArg(1)}")
			forward waitermind -m barmanCompleteOrder : barmanCompleteOrder($payloadArg(0), $payloadArg(1))
		}
	}
	Goto waitOrder
	
	State endWork {
		// Barman end work
		println("BARMAN | End work")
		terminate 0
	}
}

QActor maxstaytime context ctxtearoom {
	
	[#
		var Table = 0
	#]
	
	State s0 initial {
		// Maxstaytime initial state
		println("MAXSTAYTIME | Start")
	}
	Goto wait
	
	State wait {
		// Maxstaytime wait
		println("MAXSTAYTIME | Wait")
	}
	Transition t0	whenMsg	startTimer -> newTimer
					whenMsg resumeTimer -> resume
					whenMsg stopTimer -> stop
					whenMsg maxStayTimerExpired -> timerExpired
					whenRequest maxStayTimerLeftRequest -> timerLeft
					whenRequest maxStayTimerLeftCompareRequest -> timerLeftCompare
					whenMsg end -> endWork
	
	State newTimer {
		// Maxstaytime start new timer
		println("MAXSTAYTIME | newTimer")
		
		onMsg(startTimer : startTimer(TABLE)){
			if [# payloadArg(0).toInt() == 1 #] {
				forward maxstaytimetable1 -m startTimer : startTimer(1)
			}
			if [# payloadArg(0).toInt() == 2 #] {
				forward maxstaytimetable2 -m startTimer : startTimer(2)
			}
		}
	}
	Goto wait
	
	State resume{
		// Maxstaytime resume timer
		println("MAXSTAYTIME | resume")
		
		onMsg(resumeTimer : resumeTimer(TABLE)){
			if [# payloadArg(0).toInt() == 1 #] {
				forward maxstaytimetable1 -m resumeTimer : resumeTimer(1)
			}
			if [# payloadArg(0).toInt() == 2 #] {
				forward maxstaytimetable2 -m resumeTimer : resumeTimer(2)
			}
		}	
	}
	Goto wait
	
	State stop{
		// Maxstaytime stop timer
		println("MAXSTAYTIME | stop")
		
		onMsg(stopTimer : stopTimer(TABLE)){
			if [# payloadArg(0).toInt() == 1 #] {
				forward maxstaytimetable1 -m stopTimer : stopTimer(1)
			}
			if [# payloadArg(0).toInt() == 2 #] {
				forward maxstaytimetable2 -m stopTimer : stopTimer(2)
			}
		}
	}
	Goto wait
	
	State timerExpired{
		// Maxstaytime timer expired
		println("MAXSTAYTIME | timerExpired")

		onMsg(maxStayTimerExpired : maxStayTimerExpired(TABLE)){
			[#
				Table = payloadArg(0).toInt()
			#]
			forward waitermind -m maxStayTimerExpired : maxStayTimerExpired($Table)
		}
	}
	Goto wait
	
	State timerLeftCompare{
		onMsg (maxStayTimerLeftCompareRequest : maxStayTimerLeftCompareRequest(TABLE)){
			if [# payloadArg(0).toInt() == 1 #] {
				request maxstaytimetable1 -m maxStayTimerLeftRequestToTable : maxStayTimerLeftRequestToTable(1)
			}
			if [# payloadArg(0).toInt() == 2 #] {
				request maxstaytimetable2 -m maxStayTimerLeftRequestToTable : maxStayTimerLeftRequestToTable(2)
			}
		}
	}
	Transition t0 whenReply maxStayTimerLeftReplyFromTable -> forwardRemainingTimeCompare
	
	State forwardRemainingTimeCompare{
		onMsg(maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable(TIMERLEFT)){
			replyTo maxStayTimerLeftCompareRequest with maxStayTimerLeftCompareReply : maxStayTimerLeftCompareReply($payloadArg(0))
		}
	}
	Goto wait
	
	State timerLeft{
		onMsg (maxStayTimerLeftRequest : maxStayTimerLeftRequest(TABLE)){
			if [# payloadArg(0).toInt() == 1 #] {
				request maxstaytimetable1 -m maxStayTimerLeftRequestToTable : maxStayTimerLeftRequestToTable(1)
			}
			if [# payloadArg(0).toInt() == 2 #] {
				request maxstaytimetable2 -m maxStayTimerLeftRequestToTable : maxStayTimerLeftRequestToTable(2)
			}
		}
	}
	Transition t1 whenReply maxStayTimerLeftReplyFromTable -> forwardRemainingTime
	
	State forwardRemainingTime{
		onMsg(maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable(TIMERLEFT)){
			replyTo maxStayTimerLeftRequest with maxStayTimerLeftReply : maxStayTimerLeftReply($payloadArg(0))
		}
	}
	Goto wait
	
	State endWork {
		// Maxstaytime end work
		println("MAXSTAYTIME | End work")
		terminate 0
	}
}

QActor maxstaytimetable1 context ctxtearoom {
	
	[#
		val MaxStayTime 	= 100000L
		var StartTime 		= 0L
		var TimerDone 		= 0L
		var TimerGlobalDone = 0L
		var TimeAfterResume = 0L
		var TimerToReturn   = 0L
	#]
	
	State s0 initial {
		// Maxstaytimetable1 initial state
		println("MAXSTAYTIMETABLE1 | Start")
	}
	Goto wait
	
	State wait{
		// Maxstaytimetable1 wait
		println("MAXSTAYTIMETABLE1 | Wait")
	}
	Transition t0 	whenMsg startTimer -> newTimer
					whenMsg end -> endWork
	
	State newTimer{
		// Maxstaytimetable1 newTimer
		println("MAXSTAYTIMETABLE1 | newTimer")
		
		memoCurrentTime StartTime
		[#
			TimerGlobalDone = 0
		#]
	}
	Transition t1 	whenTimeVar MaxStayTime -> timerExpired
					whenMsg stopTimer -> stop
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDone
	
	State stop{
		// Maxstaytimetable1 stop
		println("MAXSTAYTIMETABLE1 | stop")
		
		setDuration TimerDone from StartTime
		[#
			TimerGlobalDone += TimerDone
		#]
	}
	Transition t2	whenMsg	resumeTimer -> resume
					whenMsg startTimer -> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDoneStop
	
	State resume{
		// Maxstaytimetable1 resume
		println("MAXSTAYTIMETABLE1 | resume")
		
		[#
			TimeAfterResume = MaxStayTime - TimerGlobalDone
		#]
		memoCurrentTime StartTime
	}
	Transition t3	whenTimeVar	TimeAfterResume -> timerExpired
					whenMsg	stopTimer -> stop
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDone
	
	State timerExpired{
		// Maxstaytimetable1 timerExpired
		println("MAXSTAYTIMETABLE1 | timerExpired")
		
		forward maxstaytime -m maxStayTimerExpired : maxStayTimerExpired(1)
	}
	Goto wait
	
	State returnTimerDone{
		// Maxstaytimetable1 returnTimerDone
		println("MAXSTAYTIMETABLE1 | returnTimerDone")
		
		setDuration TimerDone from StartTime
		[# 
			TimerGlobalDone += TimerDone
			TimerToReturn = MaxStayTime - TimerGlobalDone
		#]
		replyTo maxStayTimerLeftRequestToTable with maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable($TimerToReturn)
	}
	Goto resume
	
	State returnTimerDoneStop{
		// Maxstaytimetable1 returnTimerDoneStop
		println("MAXSTAYTIMETABLE1 | returnTimerDoneStop")
		
		[# 
			TimerToReturn = MaxStayTime - TimerGlobalDone
		#]
		replyTo maxStayTimerLeftRequestToTable with maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable($TimerToReturn)
	}
	Transition t4	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDoneStop
	
	State endWork {
		// Maxstaytimetable1 end work
		println("MAXSTAYTIMETABLE1 | End work")
		terminate 0
	}
}

QActor maxstaytimetable2 context ctxtearoom {
	
	[#
		val MaxStayTime 	= 100000L
		var StartTime 		= 0L
		var TimerDone 		= 0L
		var TimerGlobalDone = 0L
		var TimeAfterResume = 0L
		var TimerToReturn   = 0L
	#]
	
	State s0 initial {
		// Maxstaytimetable2 initial state
		println("MAXSTAYTIMETABLE2 | Start")
	}
	Goto wait
	
	State wait{
		// Maxstaytimetable2 wait
		println("MAXSTAYTIMETABLE2 | Wait")
	}
	Transition t0 	whenMsg startTimer -> newTimer
					whenMsg stopTimer -> wait
					whenMsg resumeTimer -> resume
					whenMsg end -> endWork
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDone
	
	State newTimer{
		// Maxstaytimetable2 newTimer
		println("MAXSTAYTIMETABLE2 | newTimer")
		
		memoCurrentTime StartTime
		[#
			TimerGlobalDone = 0
		#]
	}
	Transition t1 	whenTimeVar MaxStayTime -> timerExpired
					whenMsg stopTimer -> stop
					whenMsg startTimer -> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDone
	
	State stop{
		// Maxstaytimetable2 stop
		println("MAXSTAYTIMETABLE2 | stop")
		
		setDuration TimerDone from StartTime
		[#
			TimerGlobalDone += TimerDone
		#]
	}
	Transition t2	whenMsg	resumeTimer -> resume
					whenMsg startTimer	-> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDoneStop
	
	State resume{
		// Maxstaytimetable2 resume
		println("MAXSTAYTIMETABLE2 | resume")
		
		[#
			TimeAfterResume = MaxStayTime - TimerGlobalDone
		#]
		memoCurrentTime StartTime
	}
	Transition t3	whenTimeVar	TimeAfterResume -> timerExpired
					whenMsg	stopTimer -> stop
					whenMsg startTimer	-> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDone
	
	State timerExpired{
		// Maxstaytimetable2 timerExpired
		println("MAXSTAYTIMETABLE2 | timerExpired")
		
		forward maxstaytime -m maxStayTimerExpired : maxStayTimerExpired(2)
	}
	Goto wait
	
	State returnTimerDone{
		// Maxstaytimetable2 returnTimerDone
		println("MAXSTAYTIMETABLE2 | returnTimerDone")
		
		setDuration TimerDone from StartTime
		[# 
			TimerGlobalDone += TimerDone
			TimerToReturn = MaxStayTime - TimerGlobalDone
		#]
		replyTo maxStayTimerLeftRequestToTable with maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable($TimerToReturn)
	}
	Goto resume
	
	State returnTimerDoneStop{
		// Maxstaytimetable2 returnTimerDoneStop
		println("MAXSTAYTIMETABLE2 | returnTimerDoneStop")
		
		[# 
			TimerToReturn = MaxStayTime - TimerGlobalDone
		#]
		replyTo maxStayTimerLeftRequestToTable with maxStayTimerLeftReplyFromTable : maxStayTimerLeftReplyFromTable($TimerToReturn)
	}
	Transition t4	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest maxStayTimerLeftRequestToTable -> returnTimerDoneStop
	
	State endWork {
		// Maxstaytimetable2 end work
		println("MAXSTAYTIMETABLE2 | End work")
		terminate 0
	}
}