System -msglog tearoom

// Message between waiterengine - waitermind
Dispatch engineReady	: engineReady (PAYLOAD)
Dispatch moveTo			: moveTo (X, Y)
Dispatch done			: done (X, Y)
Dispatch stopMove		: stopMove (PAYLOAD)
Request	 clean			: clean (TABLE, STATE)
Reply	 cleanDone		: cleanDone (PAYLOAD)

// Message between waiterengine - basicrobot
Request  step 		: step (STEPTIME)
Reply    stepdone 	: stepdone (V)
Reply    stepfail   : stepfail (DURATION, CAUSE)
Dispatch cmd 		: cmd (CMD)

Dispatch goToClearing 	: goToClearing (PAYLOAD)
Dispatch goToCleaning 	: goToCleaning (PAYLOAD)
Dispatch goToSanitizing : goToSanitizing (PAYLOAD)

Dispatch end : end (PAYLOAD)


Context ctxtearoom ip [host="localhost" port=50810]
Context ctxbasicrobot ip [host="192.168.10.100" port=50800]

ExternalQActor basicrobot context ctxbasicrobot

QActor waiterengine context ctxtearoom {
	[#
		// Robot
		var StepTime = 260L
		val BackTime = 2 * StepTime / 3
		
		// Map
		val mapRoom = "teaRoomExplored"
		var XPoint = "0"
		var YPoint = "0"

		// Table state delay
		val TableClearTime = 6000L
		val TableCleanTime = 6000L
		val TableSanitizedTime = 5000L

		var CmdToMove = ""
	#]
		
	State s0 initial{
		// Initial state
		println("WAITERENGINE | Start")
		
		forward waitermind -m engineReady : engineReady(PAYLOAD)
	}
	Goto waitCmd
	
	State waitCmd{
		// Wait Cmd
		println("WAITERENGINE | Wait Cmd")
	}
	Transition t0	whenMsg moveTo -> planDestination
				 	whenMsg stopMove -> waitCmd
				 	whenRequest clean -> cleanTable
				 	whenMsg end -> endWork
	
	State planDestination{
		// Plan Destination
		println("WAITERENGINE | Plan Destination")
		println("WAITERENGINE | Start moveTo (X, Y)")
	}
	Goto readStep
	
	State readStep{
		// Read Step
		println("WAITERENGINE | Read Step")
	}
	Goto execStep if [# CmdToMove == "w" #] else execMove

	State execStep{
		// Exec Step
		println("WAITERENGINE | Exec Step")
 
		request basicrobot -m step : step(PAYLOAD)
	}
	Transition t1	whenReply stepdone -> updateMap
					whenReply stepfail -> errorHandler

	State execMove{
		// Exec Move
		println("WAITERENGINE | Exec Move")
 
		forward basicrobot -m cmd : cmd(CMD)
		delay 200
	}
	Goto updateMap
	
	State updateMap{
		// Update Map
		println("WAITERENGINE | Update Map")		
	}
	Goto checkStopEngine if [# CmdToMove.length > 0 #] else endDestination
	
	State checkStopEngine {
		println("WAITERENGINE | checkStopEngine")
	}
	Transition t2	whenTime 100 -> readStep
					whenMsg stopMove -> stopEngine
	
	State stopEngine {
		println("WAITERENGINE | stopEngine")
		
		run itunibo.planner.plannerUtil.resetActions()
	}
	Goto waitCmd
	
	State errorHandler{
		// Error Handler
		println("WAITERENGINE | Error Handler")
		    
	}
	Goto updateMap
	
	State cleanTable {
		println("WAITERENGINE | cleanTable")
		
		onMsg(clean : clean (TABLE, STATE)) {
			
			// If STATE 1
			delayVar TableClearTime
			println("WAITERENGINE | tableCleared")
			forward tearoomstatemanager -m setTableState : setTableState (TABLE, tableCleared)
			
			// If STATE 2
			delayVar TableCleanTime
			println("WAITERENGINE | tableCleaned")
			forward tearoomstatemanager -m setTableState : setTableState (TABLE, tableCleaned)
			
			// If STATE 3
			delayVar TableSanitizedTime
			println("WAITERENGINE | tableSanitized")
			forward tearoomstatemanager -m setTableState : setTableState (TABLE, tableSanitized)
		}
		replyTo clean with cleanDone : cleanDone (PAYLOAD)
	}
	Goto waitCmd
	
	State endDestination{
		// End Destination
		println("WAITERENGINE | End Destination")
		println("WAITERENGINE | Done moveTo(X,Y)")
		replyTo moveTo with done : done (X, Y)
	}
	Goto waitCmd
	
	State endWork {
		println("WAITERENGINE | End work")
		terminate 0
	}
}